export async function executeParallel(stepsOrDict, executeStep) {
    const stepStart = Date.now();
    if (Array.isArray(stepsOrDict)) {
        // Array mode: execute all in parallel
        const results = await Promise.all(stepsOrDict.map(s => executeStep(s)));
        return {
            parallelResults: results,
            durationMs: Date.now() - stepStart,
        };
    }
    else {
        // Dict mode: execute all in parallel with named keys
        const keys = Object.keys(stepsOrDict);
        const promises = keys.map(key => executeStep(stepsOrDict[key]));
        const results = await Promise.all(promises);
        const parallel = {};
        keys.forEach((key, idx) => {
            parallel[key] = results[idx];
        });
        return {
            parallel,
            durationMs: Date.now() - stepStart,
        };
    }
}
export async function executeBranch(condition, branches, history, createSubAgent) {
    const shouldTakeTrue = condition(history);
    const branch = shouldTakeTrue ? branches.true : branches.false;
    const subAgent = branch(createSubAgent());
    return await subAgent.run();
}
export async function executeSwitch(selector, cases, history, createSubAgent) {
    const value = selector(history);
    const key = String(value);
    const caseBuilder = cases[key] || cases.default;
    if (!caseBuilder) {
        throw new Error(`No matching case for value: ${key} and no default case provided`);
    }
    const subAgent = caseBuilder(createSubAgent());
    return await subAgent.run();
}
export async function executeWhile(condition, body, history, createSubAgent, opts) {
    const maxIterations = opts?.maxIterations || 10;
    const allResults = [];
    let iterations = 0;
    while (condition(history.concat(allResults)) && iterations < maxIterations) {
        const subAgent = body(createSubAgent());
        const results = await subAgent.run();
        allResults.push(...results);
        iterations++;
    }
    return allResults;
}
export async function executeForEach(items, body, createSubAgent) {
    const allResults = [];
    for (const item of items) {
        const subAgent = body(item, createSubAgent());
        const results = await subAgent.run();
        allResults.push(...results);
    }
    return allResults;
}
export async function executeRetryUntil(body, successCondition, createSubAgent, opts) {
    const maxAttempts = opts?.maxAttempts || 5;
    const backoff = opts?.backoff || 1.5;
    const allResults = [];
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const subAgent = body(createSubAgent());
        const attemptResults = await subAgent.run();
        allResults.push(...attemptResults);
        const lastResult = attemptResults[attemptResults.length - 1];
        if (successCondition(lastResult)) {
            return allResults; // Return all accumulated results
        }
        // Wait with backoff before next attempt
        if (attempt < maxAttempts - 1) {
            const waitMs = 1000 * Math.pow(backoff, attempt);
            await new Promise(resolve => setTimeout(resolve, waitMs));
        }
    }
    throw new Error(`retryUntil: Failed to meet success condition after ${maxAttempts} attempts`);
}
export async function executeRunAgent(subAgent, parentStepIndex, parentTotalSteps) {
    // Mark this as a sub-agent run to suppress progress headers/footers
    // but keep step progress for explicit composition
    subAgent.__isSubAgent = true;
    subAgent.__isExplicitSubAgent = true; // For .runAgent() - shows steps
    subAgent.__parentStepIndex = parentStepIndex;
    subAgent.__parentTotalSteps = parentTotalSteps;
    // Run the sub-agent and return its results
    return await subAgent.run();
}
