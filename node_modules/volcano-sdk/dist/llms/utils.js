/**
 * Sanitize tool names to only include alphanumeric characters, underscores, and hyphens.
 * This ensures compatibility across different LLM providers.
 */
export function sanitizeToolName(name) {
    return name.replace(/[^a-zA-Z0-9_-]/g, "_");
}
/**
 * Safely parse JSON arguments from tool calls.
 * Returns an empty object if parsing fails.
 */
export function parseToolArguments(argsJson) {
    try {
        return JSON.parse(argsJson);
    }
    catch {
        return {};
    }
}
/**
 * Create tool mapping for OpenAI-compatible providers.
 * Handles name sanitization and creates a reverse lookup map.
 */
export function createOpenAICompatibleTools(tools) {
    const nameMap = new Map();
    const formattedTools = tools.map((tool) => {
        const dottedName = tool.name;
        const sanitized = sanitizeToolName(dottedName);
        nameMap.set(sanitized, { dottedName, def: tool });
        return {
            type: "function",
            function: {
                name: sanitized,
                description: tool.description,
                parameters: tool.parameters,
            },
        };
    });
    return { nameMap, formattedTools };
}
/**
 * Parse OpenAI-compatible tool call response into LLMToolResult format.
 */
export function parseOpenAICompatibleResponse(message, nameMap) {
    const rawCalls = message?.tool_calls ?? [];
    const toolCalls = rawCalls.map((call) => {
        const sanitizedName = call?.function?.name ?? call?.name ?? "";
        const mapped = nameMap.get(sanitizedName);
        const argsJson = call?.function?.arguments ?? call?.arguments ?? "{}";
        const parsedArgs = parseToolArguments(argsJson);
        const mcpHandle = mapped?.def.mcpHandle;
        return {
            name: mapped?.dottedName ?? sanitizedName,
            arguments: parsedArgs,
            mcpHandle,
        };
    });
    return {
        content: message?.content || undefined,
        toolCalls,
    };
}
